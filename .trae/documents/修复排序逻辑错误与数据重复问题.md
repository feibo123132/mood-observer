问题分析非常精准，我看到了两个关键的 Bug：

1.  **React Key 重复报错 (`Encountered two children with the same key`)**：
    *   **原因**：从 Console 图3 可以看到，出现了重复的 Key。这通常是因为在 `useMoodStats` 钩子中，我们在进行排序或筛选时，可能意外地引入了重复数据，或者是因为在 React 的 `Strict Mode` 下，副作用被执行了两次，导致某些数据处理逻辑异常。
    *   **更深层原因**：看图2，每次点击排序，列表里就会多出一条“89分”的记录。这说明排序逻辑**不是在重排原有数组，而是在往数组里追加数据**，或者是 React 渲染时 key 冲突导致的渲染异常。
    *   **嫌疑点**：`useMoodStats.ts` 中的 `weeklyRecords` 计算逻辑。我之前使用了 `sort` 方法，`Array.prototype.sort` 是**原地修改**数组的！如果我在 `useMemo` 内部直接对 `records` 状态进行了 `sort`，就会污染原始数据或引发不可预知的副作用。虽然我之前用了 `[...recent].sort`，但如果有其他地方直接修改了引用，也会出问题。

2.  **排序混乱与数据增生**：
    *   图1显示时间乱序，图2显示数据重复。这进一步印证了数据源被污染或处理逻辑有误。

**修复方案：**

1.  **修复 `useMoodStats.ts` (核心修复)**：
    *   确保所有数据处理（筛选、排序）都严格在**新数组**上进行，绝对不修改原数组。
    *   检查 `weeklyRecords` 的依赖项，确保只在 `records` 或 `sortBy` 变化时重新计算。
    *   **关键点**：在进行排序前，先用 `slice()` 或 `[...arr]` 创建副本。

2.  **修复时间排序逻辑**：
    *   确保 `timestamp` 是数字类型，如果是字符串需要先转换。
    *   `b.timestamp - a.timestamp` 这种减法排序要求时间戳必须是数值。

3.  **UI 层的防御性编程**：
    *   在渲染列表时，虽然 key 应该是唯一的，但作为双重保险，我将检查是否有重复 ID 的数据被渲染。

我将立即修复 `src/hooks/useMoodStats.ts`。