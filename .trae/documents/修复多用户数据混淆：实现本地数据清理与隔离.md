# 修复多用户数据隔离：严格执行安全时序

完全认同您的观点：**隐私安全高于一切**。为了彻底杜绝数据“串台”，我将严格按照您指定的“安全时序”进行代码改造。

这意味着我们将**放弃**“未登录状态下的数据自动合并到登录账号”这一特性，以换取**绝对的数据隔离安全**。登录或退出操作将意味着当前本地数据的彻底销毁。

### 实施计划

#### 1. 核心销毁机制：`useMoodStore.ts`
在 MoodStore 中增加核弹级的 `clearLocalData` 方法，用于瞬间重置所有状态。

*   **修改文件**: `src/store/useMoodStore.ts`
*   **新增 Action**: `clearLocalData: () => void`
*   **逻辑**: 将 `records` 清空，`currentScore` 重置为 50，清除 `todayBaseline` 和 `lastVisitDate`。

#### 2. 安全时序执行：`useAuthStore.ts`
在 AuthStore 中，在身份切换的关键节点强制调用销毁机制。

*   **修改文件**: `src/store/useAuthStore.ts`
*   **登录前 (Pre-Login)**: 在 `login` 函数的第一行，立即调用 `useMoodStore.getState().clearLocalData()`。这确保了无论之前是谁在用，新用户进来时面对的都是一张白纸。
*   **登出时 (Logout)**: 在清除 `localStorage` 中的 token 后，立即同步调用 `clearLocalData()`。确保用户离开后，浏览器里不留下一片云彩。

#### 3. 云端同步双重保险：`useMoodStore.ts`
虽然本地数据已被清空，但在 `syncFromCloud` 中，我们依然保持警惕。

*   **确认**: 现有的 `syncFromCloud` 已经包含 `where({ userId: currentEmail })` 过滤。
*   **结果**: 由于在同步前本地数据已被 `clearLocalData` 清空，`syncFromCloud` 中的“补传逻辑”（上传本地有但云端没有的数据）将自然失效（因为本地是空的），从而完美达成“绝对不要尝试把本地残留的旧数据上传上去”的要求。

### 总结
这将构建一个严格的数据隔离墙：**只要身份发生变化（登入或登出），本地数据就立即自毁。**